# -*- coding: latin-1 -*-from PyQt4.QtGui import QImagefrom PyQt4.QtGui import qRed, qGreen, qBlue, qAlpha, qRgbafrom numpy import ndarrayfrom math  import sqrtclass ImageArray:    "To process an image using ARGB arrays"    # constructor    def __init__(self):        self.__nbR = 0  # number of raws        self.__nbC = 0  # number of columns        self.__R = None # matrix (ndarray) of red values        self.__G = None # matrix (ndarray) of green values        self.__B = None # matrix (ndarray) of blue values        self.__A = None # matrix (ndarray) of alpha values        def __InitArrays(self,raw,col):        self.__nbR = raw        self.__nbC = col        self.__R = ndarray((self.__nbR, self.__nbC), dtype=float)        self.__G = ndarray((self.__nbR, self.__nbC), dtype=float)        self.__B = ndarray((self.__nbR, self.__nbC), dtype=float)        self.__A = ndarray((self.__nbR, self.__nbC), dtype=float)    def UniColor(self, weightR, weightG, weightB):        R, G, B = self.__R, self.__G, self.__B        for r in range(self.__nbR):            for c in range(self.__nbC):                niveau =  1./3.*(R[r, c] + G[r, c] + B[r, c])                R[r, c] = weightR*niveau                G[r, c] = weightG*niveau                B[r, c] = weightB*niveau    def LoadImage(self, image):        imageloc = image.convertToFormat(QImage.Format_ARGB32)        self.__InitArrays(imageloc.height(), imageloc.width())        coef = 1./255.        for r in range(self.__nbR):            for c in range(self.__nbC):                pixel = imageloc.pixel(c, r)                self.__R[r,c] = coef*qRed(pixel)                self.__G[r,c] = coef*qGreen(pixel)                self.__B[r,c] = coef*qBlue(pixel)                self.__A[r,c] = coef*qAlpha(pixel)    def ConvertToQImage(self):        image = QImage(self.__nbC, self.__nbR, QImage.Format_ARGB32)        for r in range(self.__nbR):            for c in range(self.__nbC):                image.setPixel(c, r, qRgba( \                    int( 255.0*self.__R[r, c] + 0.5 ), \                    int( 255.0*self.__G[r, c] + 0.5 ), \                    int( 255.0*self.__B[r, c] + 0.5 ), \                    int( 255.0*self.__A[r, c] + 0.5 ) \                    ))        return image        def Negative(self):        self.__R = 1.-self.__R        self.__G = 1.-self.__G        self.__B = 1.-self.__B    #################################################################################  TRAVAIL A FAIRE :################################################################################    # TODO :  définition de la méthode publique HGradient    # TODO :  définition de la méthode publique VGradient     # TODO :  définition de la méthode publique Edge            # TODO :  définition de la méthode publique Histogram    